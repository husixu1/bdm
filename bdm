#!/usr/bin/env bash
# shellcheck disable=SC1090
# shellcheck disable=SC2181

# Startup Checking #############################################################
################################################################################
# This script requires bash >= 4.3, since it uses `declare -n`
if [[ ${BASH_VERSINFO[0]} -lt 4 ]] ||
    [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -lt 3 ]]; then
    echo "This script requires Bash version >= 4.3"
    exit 1
fi

[[ $EUID -eq 0 ]] && {
    echo "This script cannot be run as root," \
        "as it might cause unexpected damage." >&2
    exit 1
}

# TODO: rename to BDM_ROOT, replace all files
DOTFILES_ROOT=$(
    cd "$(dirname "${BASH_SOURCE[0]}")" || exit
    pwd
)
export DOTFILES_ROOT

# Init & Includes ##############################################################
################################################################################
source "$DOTFILES_ROOT/lib/utils.sh"
source "$DOTFILES_ROOT/lib/distro.sh"
source "$DOTFILES_ROOT/lib/read_ini.sh"

# Read Configs #################################################################
################################################################################
configs=(
    "$HOME/.bdm.conf"
    "$LOCAL_CONFIG_DIR/bdm.conf"
    "$LOCAL_CONFIG_DIR/bdm/bdm.conf"
    "$DOTFILES_ROOT/bdm.conf"
)

found_config=false
for config in "${configs[@]}"; do
    [[ -f "$config" ]] && {
        read_ini --prefix CONF --boolean off "$config"
        found_config=true
        break
    }
done

$found_config || {
    error "Cannot find config file"
    exit 1
}

# Termux Support ###############################################################
################################################################################
# Fake a `sudo' command, since termux does not have a sudo command
[[ $DISTRO == "termux" ]] && {
    sudo() {
        while [[ $1 =~ ^- ]]; do shift; done
        "$@"
    }
    export -f sudo
}

# FUNCTIONS ####################################################################
################################################################################
_OPTION_PATTERN='^--?[[:alnum:]][[:alnum:]-]*$'

main() {
    [[ $# -eq 0 ]] && {
        echo "$_HELP_MESSAGE"
        return 0
    }

    # Parse command line #######################################################
    ############################################################################
    # get command
    local cmd=$1
    shift

    local -A install_options=(
        [depends]="$CONF__bdm__depends"
        [usermode]="$CONF__bdm__usermode"
    )

    # TODO: add a function to export dependency graph
    case $cmd in
    i*)
        cmd="install"
        read -ra pkgs <<<"$(parse_install_args "$@")"
        install "${pkgs[@]}"
        return $?
        ;;
    u*)
        cmd="uninstall"
        read -ra pkgs <<<"$(parse_uninstall_args "$@")"
        uninstall "${pkgs[@]}"

        return $?
        ;;
    c*)
        cmd="check"
        # get options, formalize command
        while [[ $1 =~ $_OPTION_PATTERN ]]; do
            case $1 in
            *)
                error "Option $1 unrecognized"
                exit 1
                ;;
            esac
            shift
        done
        ;;
    l*)
        cmd="list" # List packages
        while [[ $1 =~ $_OPTION_PATTERN ]]; do
            case $1 in
            '-d' | '--depends')
                list_options[rundeps]=true
                ;;
            '-m' | '--makedepends')
                list_options[makedeps]=true
                ;;
            *)
                error "Option $1 unrecognized"
                exit 1
                ;;
            esac
            shift
        done

        # dotfiles to list
        local -a dotfiles

        # filter a list of valid dotfiles
        local valid_dotfiles
        valid_dotfiles="$(filter_valid_dotfiles "$@")"
        if [[ -n $valid_dotfiles ]]; then
            mapfile -t dotfiles <<<"$valid_dotfiles"
        else
            warning "No dotfile to list..."
            return 0
        fi

        if ${list_options[makedeps]}; then
            # Check for dependency loop, including makedepends
            dependency_loop_detection makedepends "${dotfiles[@]}" || {
                error "Depencency checking failed"
                return 1
            }
            # add all dependency, including makedepends to 'dotfiles' and correct their order,
            mapfile -t dotfiles < <(list_and_sort_dependencies makedepends "${dotfiles[@]}")
            echo "${dotfiles[*]}"
        elif ${list_options[rundeps]}; then
            # Check for dependency loop, including makedepends
            dependency_loop_detection rundepends "${dotfiles[@]}" || {
                error "Depencency checking failed"
                return 1
            }
            # add all dependency, including makedepends to 'dotfiles' and correct their order,
            mapfile -t dotfiles < <(list_and_sort_dependencies rundepends "${dotfiles[@]}")
            echo "${dotfiles[*]}"
        else
            echo "${dotfiles[*]}"
        fi

        return 0
        ;;
    n*)
        cmd="new" # create a new package
        # TODO some config for generating template, such as non-root, distro, function, etc
        [[ $cmd == "new" ]] && {
            info "Creating package '$1'"
            mkdir -p "$DOTFILES_ROOT/$1"
            [[ -f "$DOTFILES_ROOT/$1/bootstrap.sh" ]] && {
                error "$DOTFILES_ROOT/$1/bootstrap.sh exists."
                return 1
            }
            source "$DOTFILES_ROOT/templates/gen_bootstrap.sh" >"$DOTFILES_ROOT/$1/bootstrap.sh"
            return 0
        }
        ;;
    *)
        error "Command '$cmd' not recognized. Run '${BASH_SOURCE[0]}' for help"
        exit 1
        ;;
    esac

    # TODO: add tag support
}

# TODO: modify this
parse_install_args() {
    # get options, formalize command
    while [[ $1 =~ $_OPTION_PATTERN ]]; do
        case $1 in
        "-d" | "--depends")
            shift
            install_options[depends]="$1"
            ;;
        "-u" | "--usermode")
            shift
            install_options[usermode]="$1"
            ;;
        *)
            error "Option $1 unrecognized"
            return 1
            ;;
        esac
        shift
    done

    [[ ${install_options[depends]} == 'skip' || \
    ${install_options[depends]} == 'check' || \
    ${install_options[depends]} == 'install' ]] || {
        error "-d | --depends must be followed by one of skip|check|install"
        return 1
    }

    [[ ${install_options[usermode]} == 'true' || \
    ${install_options[usermode]} == 'false' ]] || {
        error "-u | --usermode must be followed by either 'true' or 'false'"
        return 1
    }

    export USERMODE="${install_options[usermode]}"
    echo "$@"
}

install() {
    # require root if not in usermode
    ${install_options[usermode]} || require_and_hold_root_access || return 1

    # dotfiles to install
    local -a dotfiles

    # filter a list of valid dotfiles
    local valid_dotfiles
    valid_dotfiles="$(filter_valid_dotfiles "$@")"
    if [[ -n $valid_dotfiles ]]; then
        mapfile -t dotfiles <<<"$valid_dotfiles"
    else
        warning "No dotfile to install..."
        return 0
    fi

    # Parse dependency graph
    if [[ ${install_options[depends]} != 'skip' ]]; then
        # Check for dependency loop, including makedepends
        dependency_loop_detection makedepends "${dotfiles[@]}" || {
            error "Depencency checking failed"
            return 1
        }

        if [[ ${install_options[depends]} == 'install' ]]; then
            # add all dependency to 'dotfiles' and correct their order
            mapfile -t dotfiles < <(list_and_sort_dependencies makedepends "${dotfiles[@]}")
        fi
    fi

    echo "dotfiles to check/install: ${dotfiles[*]}"
    echo -n "Proceed? [Y/n]: "
    read -r ans
    [[ $ans == n ]] && return 0

    install_dotfiles
    return $?
}

parse_uninstall_args() {
    # get options, formalize command
    while [[ $1 =~ $_OPTION_PATTERN ]]; do
        case $1 in
        *)
            error "Option $1 unrecognized"
            exit 1
            ;;
        esac
        shift
    done
    echo "$@"
}

uninstall() {
    # dotfiles to uninstall
    local -a dotfiles

    # filter a list of valid dotfiles
    local valid_dotfiles
    valid_dotfiles="$(filter_valid_dotfiles "$@")"
    if [[ -n $valid_dotfiles ]]; then
        mapfile -t dotfiles <<<"$valid_dotfiles"
    else
        warning "No dotfile to uninstall..."
        return 0
    fi

    uninstall_dotfiles
}

# $@: list of dotfiles. 'all' for every valid dotfiles
# print: list of valid dotfiles
filter_valid_dotfiles() {
    local -a dotfiles=("$@")
    [[ $1 == 'all' ]] && {
        dotfiles=()
        read -ra dotfile_dirs <<<"${CONF__bdm__dotfile_dirs:-dotfiles}"
        for dir in "${dotfile_dirs[@]}"; do
            mapfile -t list < <(ls "$DOTFILES_ROOT/$dir")
            dotfiles+=("${list[@]}")
        done
    }

    # filter out invalid dotfiles
    local -a valid_dotfiles
    for dotfile in "${dotfiles[@]}"; do
        find_dotfile_dir "$dotfile" >/dev/null && valid_dotfiles+=("$dotfile")
    done

    # return
    for dotfile in "${valid_dotfiles[@]}"; do
        echo "$dotfile"
    done
}

require_and_hold_root_access() {
    # At least `sudo` is needed
    type sudo >/dev/null 2>&1 || {
        error "the 'sudo' program is needed for running this script"
        exit 1
    }

    # Require root privilege
    if sudo -v; then
        export ISROOT=true
    else
        warning "Require root failed."
        echo "All installation process will be done in user mode."
        echo -n "Those dotfiles that requires root are doomed to fail. Proceed? [y/N]: "
        read -r ans
        if [[ $ans != y ]]; then
            return 1
        fi
        export ISROOT=false
    fi

    # keep sudo credential cache up-to-date
    while true; do
        sleep 60
        sudo -n true
        kill -0 "$$" 2>/dev/null || exit
    done &
}

# $1 dependency string
# print: two string: <type> <name>, separated with space, can be read
# into variable with `read -r type name`
# return: 1 if dependency has unknown prefix. 0 otherwise.
dependency_type_and_name() {
    local item="$1"
    if [[ $item =~ fi[[:alnum:]]*:[[:print:]]+ ]]; then
        echo "file ${item#fi*:}"
    elif [[ $item =~ v[[:alnum:]]*:[[:print:]]+ ]]; then
        echo "virtual ${item#v*:}"
    elif [[ $item =~ fu[[:alnum:]]*:[[:print:]]+ ]]; then
        echo "function ${item#fu*:}"
    elif [[ $item =~ d[[:alnum:]]*:[[:print:]]+ ]]; then
        local found=false
        for dir in "" "${ADDITIONAL_DIRS[@]}"; do
            if [[ -d $DOTFILES_ROOT/$dir/${item#d*:} ]] && [[ -f $DOTFILES_ROOT/$dir/${item#d*:}/bootstrap.sh ]]; then
                found=true
                echo "dotfile ${dir:+${dir}/}${item#d*:}"
                break
            fi
        done
        # if not found, let upper level handle this
        $found || echo "dotfile ${item#d*:}"
    elif [[ $item =~ e[[:alnum:]]*:[[:print:]]+ ]]; then
        echo "executable ${item#e*:}"
    elif [[ $item =~ [[:alnum:]]+:[[:print:]]+ ]]; then
        echo "unknown ${item#*:}"
        return 1
    else
        # noprefix, first treat as executable
        local is_executable=true
        if ! command -v "$item" >/dev/null 2>&1; then
            # if command not found, and bootstrap script for the dotfile
            # of same name is found, treat as dotfile
            for dir in "" "${ADDITIONAL_DIRS[@]}"; do
                if [[ -d $DOTFILES_ROOT/$dir/$item ]] && [[ -f $DOTFILES_ROOT/$dir/$item/bootstrap.sh ]]; then
                    is_executable=false
                    echo "dotfile ${dir:+${dir}/}$item"
                    break
                fi
            done
        fi
        # in all other cases still treat as executable
        $is_executable && echo "executable $item"
    fi
}

# $1: <rundepends|makedepends>, decide which type of dependency to include.
#     Note that makedepends implies rundepends
# ${@:1}: all dotfiles to install
dependency_loop_detection() {
    local add_makedepends=false
    [[ $1 == makedepends ]] && add_makedepends=true
    shift

    local -a exam_queue
    local -a exam_queue_level
    for dotfile in "$@"; do
        exam_queue+=("$dotfile")
        exam_queue_level+=("1")
    done

    # non-recursive DFS to find all dependency loops
    local -A deps_set
    local -a deps_stack # deps_stack[-1] is stack top
    while [[ ${#exam_queue[@]} -ne 0 ]]; do
        local cur_dotfile="${exam_queue[0]}"
        local cur_dotfile_level="${exam_queue_level[0]}"
        exam_queue=("${exam_queue[@]:1}")
        exam_queue_level=("${exam_queue_level[@]:1}")

        # set depends stack to correct level
        while [[ ${#deps_stack[@]} -ne $((cur_dotfile_level - 1)) ]]; do
            unset deps_set["${deps_stack[-1]}"]
            deps_stack=("${deps_stack[@]::${#deps_stack[@]}-1}")
        done

        # check for dependency loop
        if [[ -n ${deps_set[$cur_dotfile]} ]]; then
            local loop
            for depend in "${deps_stack[@]}"; do
                if [[ "$depend" == "$cur_dotfile" ]]; then
                    loop+="[1m[31m${depend}[0m -> "
                else
                    loop+="$depend -> "
                fi
            done
            loop+="[1m[31m$cur_dotfile[0m"
            error "Dependency loop detected: $loop"
            unset loop
            return 1
        fi

        # read all dependency of current dotfile
        if [[ ! -f "$DOTFILES_ROOT/$cur_dotfile/bootstrap.sh" ]]; then
            local chain
            chain=$(printf "%s -> " "${deps_stack[@]}")
            chain+="$cur_dotfile"
            error "Dependency chain: $chain," \
                "but 'bootstrap.sh' script for '$cur_dotfile' does not exist."
            return 1
        fi

        local -a depends
        mapfile -t depends < <(extract_dotfile_depends rundepends "$cur_dotfile")

        # add makedepends if required
        if $add_makedepends; then
            local -a makedepends
            mapfile -t makedepends < <(extract_dotfile_depends makedepends "$cur_dotfile")
            depends=("${makedepends[@]}" "${depends[@]}")
        fi

        if [[ ${#depends[@]} -ne 0 ]]; then
            exam_queue=("${depends[@]}" "${exam_queue[@]}")
            for ((i = 0; i < ${#depends[@]}; ++i)); do
                exam_queue_level=("$((cur_dotfile_level + 1))" "${exam_queue_level[@]}")
            done
            deps_stack+=("$cur_dotfile")
            deps_set["$cur_dotfile"]=1
        fi
    done
    return 0
}

# $@: all dotfiles to install
list_and_sort_dependencies() {
    local -a exam_queue
    for dotfile in "$@"; do
        exam_queue+=("$dotfile")
    done

    # Use BFS to get the topological order.
    # Yeah I know this function can be merged with dependency_loop_detection,
    # but for the sake of simplicity and readability I'll just use BFS here.
    for ((i = 0; i < ${#exam_queue[@]}; ++i)); do
        local cur_dotfile="${exam_queue[$i]}"
        local -a depends
        mapfile -t depends < <(extract_dotfile_depends rundepends "$cur_dotfile")
        if [[ ${#depends[@]} -ne 0 ]]; then
            exam_queue+=("${depends[@]}")
        fi
    done

    local -A unique_set
    for ((i = 1; i <= ${#exam_queue[@]}; ++i)); do
        if [[ -z ${unique_set[${exam_queue[-$i]}]} ]]; then
            unique_set[${exam_queue[-$i]}]=1
            echo "${exam_queue[-$i]}"
        fi
    done
}

# Extract `d*:` types dependencies from dotfiles' bootstrap file
# $1: name of the dotfile
extract_dotfile_depends() {
    (
        set -eo pipefail
        # avoid variable contamination of parent shell
        unset depends
        source "$DOTFILES_ROOT/$1/bootstrap.sh" >/dev/null 2>&1
        for depend in "${depends[@]}"; do
            read -r dep_type dep_name <<<"$(dependency_type_and_name "$depend")"
            if [[ $dep_type == dotfile ]]; then
                echo "$dep_name"
            fi
        done
    )
    error "extract_dotfile_depends: Unrecognized option $1"
    exit 1
}

# require: 'install_options' map set
# require: 'dotfiles' array set
install_dotfiles() {
    # Three steps to install all the dotfiles. the first two steps are skipped
    # if 'install_options[depends]' is skip

    for dotfile in "${dotfiles[@]}"; do
        info "Processing $dotfile ..."

        # 1. check for misisng dependencies
        if [[ ${install_options[depends]} != 'skip' ]]; then
            # 1. check if all dependencies in the 'check' array,
            # if dependency is not met, check if there's a entry in the
            # 'packages' array to install it
            local -a missing_deps=()
            mapfile -t missing_deps <<<"$(check_depends "$dotfile")" || {
                error "Unable to meet dependency(s), aborting... "
                return 1
            }
        fi

        # 2. install misisng dependencies
        if [[ ${install_options[depends]} == 'install' ]]; then
            install_depends "$dotfile" "${missing_deps[@]}"
        fi

        # 3. install dotfiles
        (
            set -eo pipefail
            # shellcheck source=./vim/bootstrap.sh

            if [[ $(type -t "install") == "function" ]]; then
                install >/dev/null
            else
                warning "'install()' not defined in '$dotfile/bootstrap.sh', skipping."
            fi
        )
        [[ $? == 0 ]] || {
            warning "Failed installing $dotfile"
            return 1
        }

        # 4. evaluate post-install function
        local post_install_func
        post_install_func="$(
            set -eo pipefail
            bootstrap_path="$(find_bootstrap_sh "$dotfile")" || return 1
            source "$bootstrap_path" >/dev/null

            if [[ $(type -t "post_install") == "function" ]]; then
                type post_install
            fi
        )"

        # the #*$'\n' suffix removes the first line of the output of `type`,
        # which should be "xxx is a function". I don't to use sed/grep here
        # as it's not pure bash.
        post_install_func="${post_install_func#*$'\n'}"
        [[ -n ${post_install_func} ]] && {
            info "Executing post_install function of $dotfile"
            eval "${post_install_func}"

            post_install || {
                error "$dotfile: Failed executing the post_install function. " \
                    "Aborting to avoid subsequent failures..."
                return 1
            }

            unset post_install
        }
    done
}

# $1 dotfile dir name
# ${install_options[depends]} affects the behavior of this function
# echo: a list of missing depends, one per line
# return: 0 for success, 1 for fail
check_depends() {
    (
        # run in subshell. exit when any error happens
        set -eo pipefail

        unset tags
        declare -a dep_check=()
        declare -A dep_install=()

        # Do not redirect stderror to allow error reporting
        # shellcheck source=./vim/bootstrap.sh
        bootstrap_path="$(find_bootstrap_sh "$1")" || return 1
        source "$bootstrap_path" >/dev/null

        # these variables are defined in subshell and
        # does not interfere with the variables outside
        declare -a missing_deps=()

        # Check dependency files before installing
        for item in "${dep_check[@]}"; do
            read -r dep_type dep_name <<<"$(dependency_type_and_name "${item}")"
            if [[ $dep_type == 'file' ]]; then
                # item is a file
                if [[ ! -e $dep_name ]]; then
                    missing_deps+=("${item}")
                fi
            elif [[ $dep_type == 'virtual' ]]; then
                # item is virtual, skip checking, but list as install
                if [[ ${install_options[depends]} == 'install' ]]; then
                    missing_deps+=("${item}")
                fi
            elif [[ $dep_type == 'function' ]]; then
                # Use a function to judge if item exists
                set +e
                (
                    set -e
                    ${item#fu*:}
                )
                if [[ $? != 0 ]]; then
                    missing_deps+=("${item}")
                fi
                set -e
            elif [[ $dep_type == 'executable' ]]; then
                if ! command -v "$dep_name" >/dev/null 2>&1; then
                    missing_deps+=("${item}")
                fi
            elif [[ $dep_type == 'dotfile' ]]; then
                # item is a dotfile
                # Check for invalid key in 'packages' array
                if [[ -n ${dep_install[$item]} ]]; then
                    warning "$dotfile: [$item]=${dep_install[$item]} in the" \
                        "'install' array is ignored. Please consider" \
                        "removing it."
                fi
                # Skip. dotfile dependency is already handled before checking.
            elif [[ $dep_type == 'unknown' ]]; then
                error "$dotfile: unrecognized dependency prefix in '${item}'"
                return 1
            fi
        done

        if [[ ${#missing_deps[@]} -gt 0 ]]; then
            warning "$dotfile: Dependency missing: ${missing_deps[*]}" >&2
        fi

        declare able_to_meet_dependency=true
        local pkg
        for dep in "${missing_deps[@]}"; do

            # pass to outer shell
            echo "$dep"

            # check if this dependency can be meet
            pkg="${dep_install["$dep"]}"
            if [[ -z $pkg ]]; then
                error "$dotfile: Cannot meet dependency '$dep': It's neither " \
                    "installed nor defined in the 'dep_install' map."
                able_to_meet_dependency=false
            fi
        done

        $able_to_meet_dependency
    )
}

# $1: dotfile dir name
# ${@:1}: a list of missing deps in the dep_check array
# return: 0 for success, 1 for fail
install_depends() {
    local dotfile=$1
    shift
    local -a missing_deps=("$@")
    # 2. install all the missing dependencies
    (
        set -eo pipefail

        # shellcheck source=./vim/bootstrap.sh
        bootstrap_path="$(find_bootstrap_sh "$dotfile")" || return 1
        source "$bootstrap_path" >/dev/null 2>&1

        for dep in "${missing_deps[@]}"; do
            declare pkg="${dep_install["$dep"]}"
            if [[ $pkg =~ f[[:alnum:]]*:[[:print:]]+ ]]; then

                # package should be installed through function, in a subshell,
                # so that set -e works correctly (both "exceptions" and returned
                # error code are captured)
                # We have to use this crooked way to simulate try-catch ...
                # see https://stackoverflow.com/questions/29532904/bash-subshell-errexit-semantics
                set +e
                (
                    set -e
                    ${pkg#f*:}
                )
                [[ $? == 0 ]] || {
                    error "$dotfile: Failed executing function ${pkg#f*:}."
                    return 1
                }
                set -e
            else
                # package should be installed through package manager.
                if $USERMODE; then
                    install_pkg_command="install_userland_package_pkgsrc ${pkg#s*:}"
                else
                    install_pkg_command="install_system_package_${DISTRO} ${pkg#s*:}"
                fi

                set +e
                (
                    set -e
                    $install_pkg_command
                )

                [[ $? == 0 ]] || {
                    error "$dotfile: Failed installing package ${pkg#s*:} " \
                        "(for dependency $dep)."
                    return 1
                }
                set -e
            fi
        done
    )
    [[ $? == 0 ]] || {
        error "Dependency installation failed, aborting... "
        return 1
    }
}

uninstall_dotfiles() {
    for dotfile in "${dotfiles[@]}"; do
        info "Processing $dotfile ..."

        # uninstall dotfiles
        (
            set -eo pipefail
            # shellcheck source=./vim/bootstrap.sh
            source "$DOTFILES_ROOT/$dotfile/bootstrap.sh" >/dev/null

            if [[ $(type -t "uninstall") == "function" ]]; then
                uninstall >/dev/null
            else
                warning "'uninstall()' not defined in '$dotfile/bootstrap.sh', skipping."
            fi
        )
        [[ $? == 0 ]] || {
            warning "Failed uninstalling $dotfile"
            return 1
        }
    done
}

# $1: name of the dotfile
# print: absolute path to the dotfile dir
# return: 1 if not found
find_dotfile_dir() {
    read -ra dotfile_dirs <<<"${CONF__bdm__dotfile_dirs:-dotfiles}"
    for dir in "${dotfile_dirs[@]}"; do
        if [[ -d "$DOTFILES_ROOT/$dir/$1" && -f \
            "$DOTFILES_ROOT/$dir/$1/bootstrap.sh" ]]; then
            echo "$DOTFILES_ROOT/$dir/$1"
            return 0
        fi
    done
    return 1
}

find_bootstrap_sh() {
    # $1: name of the dotfile
    # print: absolute path to the dotfile dir
    # return: 1 if not found
    dir=$(find_dotfile_dir "$1") || {
        error "Cannot find bootstrap.sh for $1"
        return 1
    }
    echo "$dir/bootstrap.sh"
}

_HELP_MESSAGE="\
[1mSYNOPSIS[0m
    ${BASH_SOURCE[0]} [4mCOMMAND[0m [OPTIONS] [4mPKGS[0m...

    e.g.

    ${BASH_SOURCE[0]} install vim git
    ${BASH_SOURCE[0]} install -i all
    ${BASH_SOURCE[0]} uninstall git
    ${BASH_SOURCE[0]} check tmux
    ${BASH_SOURCE[0]} list -d vim tmux

[1mCOMMAND[0m
    i*, install
        install packages specified by PKGS

    u*, uninstall
        install packages specified by PKGS

    l*, list
        list all available packages

    n*, new
        create a new package with template

[1mOPTIONS (install)[0m
    -n, --no-checkdeps
        Skip software dependency checking and install dotfiles anyway.

    -c, --checkdeps (default)
        Checks dependencies before installing. If dependency checking fails, the dotfiles will not be installed.

    -i, --installdeps (implies -c, overrides -n)
        Install dependencies automatically.

    -u, --user
        Install everything in user mode (assume no root access is granted)

    -p <PFX>, --prefix <PFX> (implies -u)
        Prefix for installing packages in user mode. Defaults to $HOME/.local

    -j <JOB_COUNT>, --jobs <JOB_COUNT>
        Number of parallel jobs for the automake system. Only applies when -u is specified. Defaults to number of cores or 4 (if number of cores cannot be detected).

[1mOPTIONS (uninstall)[0m
    Note that this bootstrap script does not provide functionality to uninstall previously installed dependencies. Please use your distro's package manager or manually uninstall the dependencies. You can check each dotfiles' bootstrap.sh to see what is installed exactly.

[1mOPTIONS (list)[0m
    -d, --depends
        Also list dependency chain for each package

    -m, --makedepends (overrides -d)
        Also list makedepends chain for each package.

[1mPKGS[0m
    <name>
        name of a package directory (e.g. vim)

    <tag>
        packages tagged with <tag>

    all
        all avaliable packages
"

# shellcheck disable=SC2016
_BOOTSTRAP_TEMPLATE="\
"'#!/usr/bin/env bash
# shellcheck disable=SC1090

source "$DOTFILES_ROOT/lib/utils.sh"
source "$DOTFILES_ROOT/lib/distro.sh"
source "$DOTFILES_ROOT/lib/symlink.sh"
source "$DOTFILES_ROOT/lib/transaction.sh"

THISDIR=$(
    cd "$(dirname "${BASH_SOURCE[0]}")" || exit
    pwd -P
)

declare -a depends=()
declare -a makedepends=()
declare -A packages=()

declare -a tags=(t:r:arch t:u:arch)

if $ISROOT; then
    if [[ $DISTRO == arch ]]; then
        # packages+=()
        : # add more distros with #elif
    fi
else
    # non-root installation
    # makedepends=(gnu-tools tar curl)
    packages+=()
    # install<Package>() {
    #     local tempdir
    #     tempdir=$(mktemp -d)
    #     pushd "$tempdir" || exit 1
    #     # ...
    #     popd || exit 1
    #     rm -rf "$tempdir"
    # }
fi

export depends
export makedepends
export packages
export tags

################################################################################

install() {
    transaction
    # transactionInstallSymlink "$THISDIR/a" "$LOCAL_CONFIG_DIR/b"
    commit
}

uninstall() {
    transaction
    # transactionRemoveSymlink "$THISDIR/a" "$LOCAL_CONFIG_DIR/b"
    commit
}
'

main "$@"
